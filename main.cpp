// syntax analyzer code written in cpp

#include "usefulheaders.hpp"
#include <iostream>
#include "sNode.hpp"
#include "customstack.cpp"
// #include "printer.cpp"
//  RUN CODE BY TYPING g++ main.c lex.cpp sNode.cpp -o main.exe
//   then do main.exe > main.out

// I split the syntax analyser and the lexical analyser into 2 files for clarity sake, my monitor is small so I can't keep scrolling between the lexical analyser and the syntax analyser on one file and I added a header file just to safeguard all the necessary tokens for this

/*
EBNF GRAMMAR
<program> -> <declare_list>{<declare_list>|<assign_list>}
<declare_list> -> (int|float) <ident> [=<const_expr>]{,<ident>[=<const_expr>]
<assign_list> -> {<ident>=}<expr>
<expr> -> <term> {(+ | -) <term>}
<term> -> <factor> {(* | /) <factor>)
<factor> -> id | int_constant | ( <expr> ) | float_const
*/

/*

Sematic attribute grammar rules


*/
sNode *assign();
sNode *assign_list();
sNode *expr();
sNode *term();
sNode *factor();
sNode *declare_list();
sNode *program();
sNode *root;
struct SymbolInfo;
std::unordered_map<std::string, SymbolInfo> symbolTable;
void printSymbolTable(const std::unordered_map<std::string, SymbolInfo> &table);
void process_single_declaration(Datatype type);
void printTree(sNode *node, int depth = 0);
static void printIndent(int depth);
std::string typeToString(Datatype t);
Datatype getVariableType(char id);
void computeTypes(sNode *node);
void generatePostfix(sNode* node);
// the literal name of the identifier to be inserted into the symbol table
std::string name;
// used as a placeholder until I can find something more concrete
Datatype currDatatype;



//Intermediate language code functions 
void ftoi();
void itof();
void iadd();
void fadd();
void fmult();
void imult();
void fdiv();
void idiv();
void isub();
void fsub();

/******************************************************/
/* main driver */
int main()
{
    /* Open the input data file and process its contents */
    if ((in_fp = fopen("front.in", "r")) == NULL)
        printf("ERROR - cannot open front.in \n");
    else
    {
        getChar();
        lex();
        root = program();
    }
    computeTypes(root);
    // printSymbolTable(symbolTable);
    //printTree(root);
    generatePostfix(root);
}

//<program> -> <declare_list>{<declare_list>|<assign_list>}
sNode *program()
{
    sNode *first = nullptr;
    sNode *last = nullptr;

    // First, process declarations if present
    while (nextToken == INT_KEYWORD || nextToken == FLOAT_KEYWORD)
    {
        declare_list(); // fills symbol table, returns nullptr
        // no AST nodes to link
    }

    // Process assignments if present
    while (nextToken == IDENT)
    {
        sNode *nextNode = assign_list();
        if (!first)
            first = nextNode; // first assignment becomes AST root
        if (last)
            last->right = nextNode;
        last = nextNode;
    }

    return first; // AST only contains assignment nodes
}

/* assign
Parses strings in the language generated by the rule:
<assign> -> <ident> = <expr>
*/
sNode *assign()
{
    // std::cout << "Enter <assign>" << std::endl;
    //  if the start of the front.in is an IDENT = <expr>, to show optional {unsigned|signed} we can run a while loop if the
    if (nextToken == IDENT)
    {
        // so we must create an sNode for the assign = <expr>
        // we will start with making the lhs which is the identifier node
        sNode::Content c;
        c.identifier = lexeme_s[0];

        // this is a simple sNode that creates an identifier node, after we parse through expr,
        // we must create a sNode that sets this lhs Node equal the the rhs.
        sNode *lhs = sNode::mkSnode(sNode::IDENTIFIER, c, nullptr, nullptr);
        // get the next token
        lex();
        // the assignment supports the {int|float)} but doesn't change the lexical analyser functionality, by support, means that the lexical analyser recognizes that the keywords and incremental operators are there and will continue with our regular grammar rules.
        // by extension, the assignment will compute the next character by calling lex and then go into expr from our grammar rules
        if (nextToken == ASSIGN_OP)
        {
            lex();
            // the rhs is the rhs of the = obvs
            sNode *rhs = expr();
            // setting the '=' for the rhs and lhs to create the sNode
            sNode::Content opContent;
            opContent.op = '=';
            return sNode::mkSnode(sNode::OP, opContent, lhs, rhs);
        }
        else
        {
            std::cerr << "Error, expected = ";
            return nullptr;
        }
    }
}

/* expr
Parses strings in the language generated by the rule:
<expr> -> <term> {(+ | -) <term>}
*/
sNode *expr()
{
    // incrementGlobalDepth();
    // std::cout << "Enter " << depth << ".<expr>" << std::endl;
    /* Parse the first term */
    sNode *left = term();
    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP)
    {
        // fancy notation for which operator to save based on the which token is provided
        char op = (nextToken == ADD_OP ? '+' : '-');
        lex();
        // right hand side of <expr) -> <term> {(+|-) <term>}
        sNode *right = term();
        sNode::Content opContent;
        opContent.op = op;

        // the left node will always be equal to whatever is added on from the right, thats why we keep re assigning it.
        //  if the right is null like the grammar implies it can be, then we still return a term();
        left = sNode::mkSnode(sNode::OP, opContent, left, right);
    }
    return left;
    // std::cout << "Exit " << depth << ".<expr>" << std::endl;
    // decrementGlobalDepth();
} /* End of function expr */

/* term
Parses strings in the language generated by the rule:
<term> -> <factor> {(* | /) <factor>)
*/
// pretty much the same as the <expr> expect with (*|/)
sNode *term()
{

    /* Parse the first factor */
    sNode *lhs = factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP)
    {
        char op = (nextToken == MULT_OP ? '*' : '/');
        lex();

        sNode *right = factor();
        sNode::Content opContent;
        // the operator that we set for the node is based of the char op
        opContent.op = op;
        lhs = sNode::mkSnode(sNode::OP, opContent, lhs, right);
    }
    return lhs;

} /* End of function term */

/* factor
Parses strings in the language generated by the rule:
<factor> -> id | int_constant | ( <expr> ) | float_const
*/

// for now, ill assume all identifiers are chars with one word because for some reason, unions in cpp cant deal with strings and I would have to use a struct for that case, i.e int k = 0 works but int kk = 0 wont because kk is a string
sNode *factor()
{
    if (nextToken == IDENT)
    {
        sNode::Content c;
        c.identifier = lexeme_s[0];
        sNode *n = sNode::mkSnode(sNode::IDENTIFIER, c, nullptr, nullptr);
        lex();
        return n;
    }

    if (nextToken == INT_CONST)
    {
        sNode::Content c;
        c.integer_constant = integerLiteral;
        sNode *n = sNode::mkSnode(sNode::INT_CONSTANT, c, nullptr, nullptr);
        lex();
        return n;
    }

    if (nextToken == FLOAT_CONST)
    {
        sNode::Content c;
        c.float_constant = floatLiteral; //
        sNode *n = sNode::mkSnode(sNode::FLOAT_CONSTANT, c, nullptr, nullptr);
        lex();
        return n;
    }

    if (nextToken == LEFT_PAREN)
    {
        lex();             // consume '('
        sNode *n = expr(); // parse inner expression
        if (nextToken == RIGHT_PAREN)
            lex(); // consume ')'
        else
            std::cout << "Error: expected ')'" << std::endl;
        return n;
    }

    std::cout << "Error: unexpected token in factor" << std::endl;
    return nullptr;
}

// declare_list -> (int|float) <ident> [=<expr>]{,<ident>[=<expr>]}
sNode *declare_list()
{
    // Determine type
    if (nextToken == INT_KEYWORD)
        currDatatype = TYPE_INT;
    else if (nextToken == FLOAT_KEYWORD)
        currDatatype = TYPE_FLOAT;
    else
    {
        std::cout << "Error: expected type specifier\n";
        return nullptr;
    }

    lex(); // consume int|float

    // First identifier
    if (nextToken != IDENT)
    {
        std::cout << "Error: expected identifier after type\n";
        return nullptr;
    }

    // Process the first declaration (this consumes IDENT and optional initializer)
    process_single_declaration(currDatatype);

    // Now handle comma-separated further declarations.
    while (nextToken == COMMA)
    {
        lex(); // consume comma

        if (nextToken != IDENT)
        {
            std::cout << "Error: expected identifier after comma\n";
            return nullptr;
        }

        process_single_declaration(currDatatype);
    }

    // Declaration list doesn't produce AST nodes in your design
    return nullptr;
}
//<assign_list> -> {<ident>=}<assign>
// need to figure out how to handle cases for a = b = ..., like what should the symbol table hold?
// ANSWER TO ABOVE -> PARSER WONT NEED TO HANDLE THIS, THE PARSER WILL ONLY BUILD THE TREE
sNode *assign_list()
{
    if (nextToken != IDENT)
        return nullptr;

    // left-hand side
    sNode::Content c;
    c.identifier = lexeme_s[0];
    sNode *lhs = sNode::mkSnode(sNode::IDENTIFIER, c, nullptr, nullptr);
    lex(); // consume IDENT

    if (nextToken == ASSIGN_OP)
    {
        lex(); // consume '='

        sNode *rhs = nullptr;
        // If next token is IDENT, recursively parse assignment
        if (nextToken == IDENT)
            rhs = assign_list();
        else
            rhs = expr(); // otherwise parse an expression (parentheses, constants, etc.)

        sNode::Content opContent;
        opContent.op = '=';
        return sNode::mkSnode(sNode::OP, opContent, lhs, rhs);
    }

    return expr(); // fallback, shouldn't happen for proper assignment
}

void printSymbolTable(const std::unordered_map<std::string, SymbolInfo> &table)
{
    std::cout << "Name | Type | Value" << std::endl;
    std::cout << "----------------------" << std::endl;
    for (const auto &entry : table)
    {
        const std::string &lname = entry.first;
        const SymbolInfo &info = entry.second;

        std::cout << lname << "  |  ";

        switch (info.type)
        {
        case TYPE_INT:
            std::cout << "INT   ";
            if (info.initialized)
                std::cout << info.value.i;
            else
                std::cout << "(uninitialized)";
            break;

        case TYPE_FLOAT:
            std::cout << "FLOAT ";
            if (info.initialized)
                std::cout << info.value.f;
            else
                std::cout << "(uninitialized)";
            break;

        default:
            std::cout << "UNKNOWN";
        }

        std::cout << std::endl;
    }
}

void process_single_declaration(Datatype type)
{
    std::string name = lexeme_s; // full identifier name

    // Insert or update symbol table entry
    symbolTable[name].type = type;
    symbolTable[name].initialized = false;

    lex(); // consume IDENT

    // Optional initializer
    if (nextToken == ASSIGN_OP)
    {
        lex(); // consume '='

        // ---- INT variable initialization ----
        if (type == TYPE_INT)
        {
            if (nextToken == INT_CONST)
            {
                symbolTable[name].value.i = integerLiteral;
                symbolTable[name].initialized = true;
            }
            else
            {
                std::cout << "Type error: cannot assign non-int constant to int variable '"
                          << name << "'\n";
            }
        }
        // ---- FLOAT variable initialization ----
        else if (type == TYPE_FLOAT)
        {
            if (nextToken == FLOAT_CONST)
            {
                symbolTable[name].value.f = floatLiteral;
                symbolTable[name].initialized = true;
            }
            else if (nextToken == INT_CONST)
            {
                // Optional: allow int -> float promotion
                symbolTable[name].value.f = std::stof(lexeme_s);
                symbolTable[name].initialized = true;
            }
            else
            {
                std::cout << "Type error: invalid constant for float variable '"
                          << name << "'\n";
            }
        }

        lex(); // consume constant
    }
}

static void printIndent(int depth)
{
    for (int i = 0; i < depth; i++)
        std::cout << "  ";
}

void printTree(sNode *node, int depth)
{
    if (!node)
        return;

    // Indentation
    for (int i = 0; i < depth; ++i)
        std::cout << "  ";

    // Print node info
    switch (node->tag)
    {
    case sNode::IDENTIFIER:
        std::cout << "IDENTIFIER: " << node->data.identifier;
        break;

    case sNode::INT_CONSTANT:
        std::cout << "INT_CONSTANT: " << node->data.integer_constant;
        break;

    case sNode::FLOAT_CONSTANT:
        std::cout << "FLOAT_CONSTANT: " << node->data.float_constant;
        break;

    case sNode::OP:
        std::cout << "OP: " << node->data.op;
        break;

    default:
        std::cout << "UNKNOWN NODE";
    }

    // Print computed and expected types
    std::cout << " [computed: " << typeToString(node->computedType)
              << ", expected: " << typeToString(node->expectedType) << "]"
              << std::endl;

    // Recurse to children
    printTree(node->left, depth + 1);
    printTree(node->right, depth + 1);
}

void computeTypes(sNode *node)
{
    if (!node)
        return;

    // Post-order traversal
    computeTypes(node->left);
    computeTypes(node->right);

    switch (node->tag)
    {
    case sNode::INT_CONSTANT:
        node->computedType = TYPE_INT;
        node->expectedType = TYPE_INT;
        break;

    case sNode::FLOAT_CONSTANT:
        node->computedType = TYPE_FLOAT;
        node->expectedType = TYPE_FLOAT;
        break;

    case sNode::IDENTIFIER:
        node->computedType = getVariableType(node->data.identifier); // returns Datatype
        node->expectedType = node->computedType;
        break;

    case sNode::OP:
        if (node->data.op == '+' || node->data.op == '-' ||
            node->data.op == '*' || node->data.op == '/')
        {
            // Binary arithmetic operators
            if (node->left->computedType == TYPE_FLOAT ||
                node->right->computedType == TYPE_FLOAT)
                node->computedType = TYPE_FLOAT;
            else
                node->computedType = TYPE_INT;

            node->expectedType = node->computedType;
        }
        else if (node->data.op == '=')
        {
            // Assignment
            node->expectedType = node->left->computedType;  // LHS type
            node->computedType = node->right->computedType; // RHS type

            if (node->left->computedType != node->right->computedType)
            {
                std::cout << "Type mismatch in assignment: "
                          << node->left->data.identifier << std::endl;
            }
        }
        break;

    default:
        node->computedType = TYPE_UNKNOWN;
        node->expectedType = TYPE_UNKNOWN;
        break;
    }
}

Datatype getVariableType(char id)
{
    std::string name(1, id); // convert char to string
    if (symbolTable.find(name) != symbolTable.end())
        return symbolTable[name].type;
    return TYPE_UNKNOWN;
}

// Helper to convert Type enum to string
std::string typeToString(Datatype t)
{
    switch (t)
    {
    case TYPE_INT:
        return "INT";
    case TYPE_FLOAT:
        return "FLOAT";
    default:
        return "UNKNOWN";
    }
}

void generatePostfix(sNode* node) {
    if (!node) return;

    // Left subtree
    generatePostfix(node->left);

    // Right subtree
    generatePostfix(node->right);

    // Print current node
    switch (node->tag) {
        case sNode::INT_CONSTANT:
            std::cout << node->data.integer_constant << " ";
            break;

        case sNode::FLOAT_CONSTANT:
            std::cout << node->data.float_constant << " ";
            break;

        case sNode::IDENTIFIER:
            std::cout << node->data.identifier << " ";
            break;

        case sNode::OP:
            std::cout << node->data.op << " ";
            break;
    }
}
