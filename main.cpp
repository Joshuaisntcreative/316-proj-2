// syntax analyzer code written in cpp

#include "usefulheaders.hpp"
#include <iostream>
#include "sNode.hpp"
// RUN CODE BY TYPING g++ main.c lex.cpp -o main.exe
//  then do main.exe > main.out

// I split the syntax analyser and the lexical analyser into 2 files for clarity sake, my monitor is small so I can't keep scrolling between the lexical analyser and the syntax analyser on one file and I added a header file just to safeguard all the necessary tokens for this

sNode *assign();
sNode *assign_list();
sNode *expr();
sNode *term();
sNode *factor();
sNode *declare_list();
struct SymbolInfo;
std::unordered_map<std::string, SymbolInfo> symbolTable;
void printSymbolTable(std::unordered_map<std::string, SymbolInfo> map);
std::string name;
int depth = 0;
// used as a placeholder until I can find something more concrete
DataType currDatatype;

int incrementGlobalDepth()
{
    return depth += 1;
}

int decrementGlobalDepth()
{
    return depth -= 1;
}
/******************************************************/
/* main driver */
int main()
{
    /* Open the input data file and process its contents */
    if ((in_fp = fopen("front.in", "r")) == NULL)
        printf("ERROR - cannot open front.in \n");
    else
    {
        getChar();
        do
        {
            lex();
            sNode* programNode = declare_list();
            lex();
            //must check for multiple declare_lists | assign_lists
            if(nextToken == INT_KEYWORD || nextToken == FLOAT_KEYWORD || nextToken == IDENT)
            {
                sNode* nextNode = nullptr;
                if(nextToken == INT_KEYWORD || nextToken == FLOAT_KEYWORD)
                {
                    nextNode = declare_list();
                }
                else{
                    nextNode = assign_list();
                }
            }
        } while (nextToken != EOF);
        printSymbolTable(symbolTable);
    }
}

/* assign
Parses strings in the language generated by the rule:
<assign> -> <ident> = <expr>
*/
sNode *assign()
{
    // std::cout << "Enter <assign>" << std::endl;
    //  if the start of the front.in is an IDENT = <expr>, to show optional {unsigned|signed} we can run a while loop if the
    if (nextToken == IDENT)
    {
        // so we must create an sNode for the assign = <expr>
        // we will start with making the lhs which is the identifier node
        sNode::Content c;
        c.identifier = lexeme_s[0];

        // this is a simple sNode that creates an identifier node, after we parse through expr,
        // we must create a sNode that sets this lhs Node equal the the rhs.
        sNode *lhs = sNode::mkSnode(sNode::IDENTIFIER, c, nullptr, nullptr);
        // get the next token
        lex();
        // the assignment supports the {int|float)} but doesn't change the lexical analyser functionality, by support, means that the lexical analyser recognizes that the keywords and incremental operators are there and will continue with our regular grammar rules.
        // by extension, the assignment will compute the next character by calling lex and then go into expr from our grammar rules
        if (nextToken == ASSIGN_OP)
        {
            lex();
            // the rhs is the rhs of the = obvs
            sNode *rhs = expr();
            //setting the '=' for the rhs and lhs to create the sNode
            sNode::Content opContent;
            opContent.op = '=';
            return sNode::mkSnode(sNode::OP, opContent, lhs, rhs);
        }
        else{
            std::cerr << "Error, expected = ";
            return nullptr;
        }
    }
}

/* expr
Parses strings in the language generated by the rule:
<expr> -> <term> {(+ | -) <term>}
*/
sNode *expr()
{
    // incrementGlobalDepth();
    // std::cout << "Enter " << depth << ".<expr>" << std::endl;
    /* Parse the first term */
    sNode *left = term();
    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP)
    {
        // fancy notation for which operator to save based on the which token is provided
        char op = (nextToken == ADD_OP ? '+' : '-');
        lex();
        // right hand side of <expr) -> <term> {(+|-) <term>}
        sNode *right = term();
        sNode::Content opContent;
        opContent.op = op;

        //the left node will always be equal to whatever is added on from the right, thats why we keep re assigning it.
        // if the right is null like the grammar implies it can be, then we still return a term();
        left = sNode::mkSnode(sNode::OP, opContent, left, right);
    }
    return left;
    // std::cout << "Exit " << depth << ".<expr>" << std::endl;
    // decrementGlobalDepth();
} /* End of function expr */

/* term
Parses strings in the language generated by the rule:
<term> -> <factor> {(* | /) <factor>)
*/
//pretty much the same as the <expr> expect with (*|/)
sNode *term()
{

    /* Parse the first factor */
    sNode* lhs = factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP)
    {
        char op = (nextToken == MULT_OP ? '*' : '/');
        lex();

        sNode *right = factor();
        sNode::Content opContent;
        //the operator that we set for the node is based of the char op
        opContent.op = op;
        lhs = sNode::mkSnode(sNode::OP, opContent, lhs, right);
    }
    return lhs;

} /* End of function term */

/* factor
Parses strings in the language generated by the rule:
<factor> -> id | int_constant | ( <expr> ) | float_const
*/

// for now, ill assume all identifiers are chars with one word because for some reason, unions in cpp cant deal with strings and I would have to use a struct for that case, i.e int k = 0 works but int kk = 0 wont because kk is a string
sNode *factor()
{
    incrementGlobalDepth();
    std::cout << "Enter " << depth << ".<factor>" << std::endl;

    if (nextToken == IDENT) //|| nextToken == INT_CONST|| nextToken == FLOAT_CONST)
    {
        sNode::Content c;
        c.identifier = lexeme_s[0];
        sNode *n = sNode::mkSnode(
            sNode::IDENTIFIER, c, nullptr, nullptr);
        lex();
        return n;
    }

    if (nextToken == INT_CONST)
    {
        sNode::Content c;
        c.integer_constant = integerLiteral;
        sNode *n = sNode::mkSnode(
            sNode::INT_CONSTANT, c, nullptr, nullptr);
        lex();
        return n;
    }
    // have to add integer literal flexibility to also handle floats.
    if (nextToken == FLOAT_CONST)
    {
        sNode::Content c;
        c.float_constant = integerLiteral;
        sNode *n = sNode::mkSnode(
            sNode::FLOAT_CONSTANT, c, nullptr, nullptr);
        lex();
        return n;
    }
    else
    {
        if (nextToken == LEFT_PAREN)
        {
            lex();
            expr();
            if (nextToken == RIGHT_PAREN)
                lex();
            else
                std::cout << "Error" << std::endl;
        } /* End of if (nextToken == ... */
        /* It was not an id, an integer literal, or a left
        parenthesis */
    } /* End of else */
} /* End of function factor */

sNode *declare_list()
{
    while (nextToken == INT_KEYWORD || nextToken == FLOAT_KEYWORD)
    {
        // 1. Identify type
        if (nextToken == INT_KEYWORD)
        {
            currDatatype = TYPE_INT;
        }
        else if (nextToken == FLOAT_KEYWORD)
        {
            currDatatype = TYPE_FLOAT;
        }
        else
        {
            // debugging purposes
            currDatatype = TYPE_UNKNOWN;
        }
        lex();
        // Need a way to save the datatype of the identifier and put the value in a symbol table so the, we will use a hashmap for now
        if (nextToken == IDENT)
        {
            name = lexeme_s;                       // your lexer should store identifier text
            symbolTable[name].type = currDatatype; // insert into hashmap

            lex(); // consume IDENT
            if (nextToken == ASSIGN_OP)
            {
                lex();
                // const value so either a identifier or a digit
                if (nextToken == IDENT || nextToken == DIGIT)
                {
                    if (nextToken == DIGIT)
                    {
                        // should create an sNode here
                        symbolTable[name].value = integerLiteral;
                    }
                    // two possible cases
                    // dont know how to handle other other case where a variable is equal to another variable(i.e what is the symbol table value supposed to be in that case so ill leave that alone for now )
                }
            }
        }
        else
        {
            std::cout << ("Identifier expected after datatype");
        }
        // after something like int a we'd call lex to check if the next token is comma or not

        // allows commas like int a,b,c;
        while (nextToken == COMMA)
        {
            lex();
            if (nextToken != IDENT)
                std::cout << ("Identifier expected after comma");
            symbolTable[lexeme_s].type = currDatatype;
            lex();
        }
    }
}
//<assign_list> -> {<ident>=}<assign>
// need to figure out how to handle cases for a = b = ..., like what should the symbol table hold?
// ANSWER TO ABOVE -> PARSER WONT NEED TO HANDLE THIS, THE PARSER WILL ONLY BUILD THE TREE
sNode *assignList()
{
    while (nextToken == IDENT)
    {
        sNode::Content c;
        c.identifier = lexeme_s[0];
        sNode *idNode = sNode::mkSnode(sNode::IDENTIFIER, c, nullptr, nullptr);
        lex();
        if (nextToken == ASSIGN_OP)
        {
            lex();
            // this represents the multiple times that can be allowed in the grammar {<ident>=}
            sNode *rhs = assign_list();

            sNode::Content opContent;
            opContent.op = '=';

            // want to assign idNode to equal the contents on the right hand side that we parse, we will create an operator node with the assign op and have the left and right child be idNode and rhs respectively.
            return sNode::mkSnode(sNode::OP, opContent, idNode, rhs);
        }
    }
    return assign();
}

void printSymbolTable(std::unordered_map<std::string, SymbolInfo> map)
{
    for (auto i : map)
    {
        std::cout << i.first << " is the name of the identifier and " << i.second.type << " is the type of variable " << i.second.value << " is the value inside" << std::endl;
    }
}
