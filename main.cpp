// syntax analyzer code written in cpp

#include "usefulheaders.hpp"
#include <iostream>
#include "sNode.hpp"
//#include "printer.cpp"
// RUN CODE BY TYPING g++ main.c lex.cpp -o main.exe
//  then do main.exe > main.out

// I split the syntax analyser and the lexical analyser into 2 files for clarity sake, my monitor is small so I can't keep scrolling between the lexical analyser and the syntax analyser on one file and I added a header file just to safeguard all the necessary tokens for this

sNode *assign();
sNode *assign_list();
sNode *expr();
sNode *term();
sNode *factor();
sNode *declare_list();
sNode *program();
sNode *root;
struct SymbolInfo;
std::unordered_map<std::string, SymbolInfo> symbolTable;
void printSymbolTable(const std::unordered_map<std::string, SymbolInfo>& table);
void process_single_declaration(Datatype type);
//the literal name of the identifier to be inserted into the symbol table
std::string name;
// used as a placeholder until I can find something more concrete
Datatype currDatatype;


/******************************************************/
/* main driver */
int main()
{
    /* Open the input data file and process its contents */
    if ((in_fp = fopen("front.in", "r")) == NULL)
        printf("ERROR - cannot open front.in \n");
    else
    {
        getChar();
        lex();
        root = program();
    }
    printSymbolTable(symbolTable);
}
sNode *program()
{

    sNode* first = nullptr;
    sNode* last = nullptr;

    if(nextToken == INT_KEYWORD || nextToken == FLOAT_KEYWORD)
    {
        first = declare_list();
        last = first;
    }
    else{
        std::cout << "Program must start with declareList" << std::endl;
    }
    lex();

   while (nextToken == INT_KEYWORD || nextToken == FLOAT_KEYWORD || nextToken == IDENT)
   {
    sNode* nextNode = nullptr;

    if(nextToken == INT_KEYWORD || nextToken == FLOAT_KEYWORD)
    {
        nextNode = declare_list();
    }
    else{
        nextNode = assign_list();
    }

    last -> right = nextNode;
    last = nextNode;
    //lex();
   }
   return first;
}

/* assign
Parses strings in the language generated by the rule:
<assign> -> <ident> = <expr>
*/
sNode *assign()
{
    // std::cout << "Enter <assign>" << std::endl;
    //  if the start of the front.in is an IDENT = <expr>, to show optional {unsigned|signed} we can run a while loop if the
    if (nextToken == IDENT)
    {
        // so we must create an sNode for the assign = <expr>
        // we will start with making the lhs which is the identifier node
        sNode::Content c;
        c.identifier = lexeme_s[0];

        // this is a simple sNode that creates an identifier node, after we parse through expr,
        // we must create a sNode that sets this lhs Node equal the the rhs.
        sNode *lhs = sNode::mkSnode(sNode::IDENTIFIER, c, nullptr, nullptr);
        // get the next token
        lex();
        // the assignment supports the {int|float)} but doesn't change the lexical analyser functionality, by support, means that the lexical analyser recognizes that the keywords and incremental operators are there and will continue with our regular grammar rules.
        // by extension, the assignment will compute the next character by calling lex and then go into expr from our grammar rules
        if (nextToken == ASSIGN_OP)
        {
            lex();
            // the rhs is the rhs of the = obvs
            sNode *rhs = expr();
            //setting the '=' for the rhs and lhs to create the sNode
            sNode::Content opContent;
            opContent.op = '=';
            return sNode::mkSnode(sNode::OP, opContent, lhs, rhs);
        }
        else{
            std::cerr << "Error, expected = ";
            return nullptr;
        }
    }
}

/* expr
Parses strings in the language generated by the rule:
<expr> -> <term> {(+ | -) <term>}
*/
sNode *expr()
{
    // incrementGlobalDepth();
    // std::cout << "Enter " << depth << ".<expr>" << std::endl;
    /* Parse the first term */
    sNode *left = term();
    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP)
    {
        // fancy notation for which operator to save based on the which token is provided
        char op = (nextToken == ADD_OP ? '+' : '-');
        lex();
        // right hand side of <expr) -> <term> {(+|-) <term>}
        sNode *right = term();
        sNode::Content opContent;
        opContent.op = op;

        //the left node will always be equal to whatever is added on from the right, thats why we keep re assigning it.
        // if the right is null like the grammar implies it can be, then we still return a term();
        left = sNode::mkSnode(sNode::OP, opContent, left, right);
    }
    return left;
    // std::cout << "Exit " << depth << ".<expr>" << std::endl;
    // decrementGlobalDepth();
} /* End of function expr */

/* term
Parses strings in the language generated by the rule:
<term> -> <factor> {(* | /) <factor>)
*/
//pretty much the same as the <expr> expect with (*|/)
sNode *term()
{

    /* Parse the first factor */
    sNode* lhs = factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP)
    {
        char op = (nextToken == MULT_OP ? '*' : '/');
        lex();

        sNode *right = factor();
        sNode::Content opContent;
        //the operator that we set for the node is based of the char op
        opContent.op = op;
        lhs = sNode::mkSnode(sNode::OP, opContent, lhs, right);
    }
    return lhs;

} /* End of function term */

/* factor
Parses strings in the language generated by the rule:
<factor> -> id | int_constant | ( <expr> ) | float_const
*/

// for now, ill assume all identifiers are chars with one word because for some reason, unions in cpp cant deal with strings and I would have to use a struct for that case, i.e int k = 0 works but int kk = 0 wont because kk is a string
sNode *factor()
{
    if (nextToken == IDENT) //|| nextToken == INT_CONST|| nextToken == FLOAT_CONST)
    {
        sNode::Content c;
        c.identifier = lexeme_s[0];
        sNode *n = sNode::mkSnode(
            sNode::IDENTIFIER, c, nullptr, nullptr);
        lex();
        return n;
    }

    if (nextToken == INT_CONST)
    {
        sNode::Content c;
        c.integer_constant = integerLiteral;
        sNode *n = sNode::mkSnode(
            sNode::INT_CONSTANT, c, nullptr, nullptr);
        lex();
        return n;
    }
    // have to add integer literal flexibility to also handle floats.
    if (nextToken == FLOAT_CONST)
    {
        sNode::Content c;
        c.float_constant = integerLiteral;
        sNode *n = sNode::mkSnode(
            sNode::FLOAT_CONSTANT, c, nullptr, nullptr);
        lex();
        return n;
    }
    else
    {
        if (nextToken == LEFT_PAREN)
        {
            lex();
            sNode* n = expr();
            if (nextToken == RIGHT_PAREN)
                lex();
            else
                std::cout << "Error" << std::endl;
            return n;
        } /* End of if (nextToken == ... */

        /* It was not an id, an integer literal, or a left
        parenthesis */
    } /* End of else */
} /* End of function factor */

//declare_list -> (int|float) <ident> [=<expr>]{,<ident>[=<expr>]}
sNode* declare_list()
{
    // Determine type
    if (nextToken == INT_KEYWORD)
        currDatatype = TYPE_INT;
    else if (nextToken == FLOAT_KEYWORD)
        currDatatype = TYPE_FLOAT;
    else {
        std::cout << "Error: expected type specifier\n";
        return nullptr;
    }

    lex();  // consume int|float

    // First identifier
    if (nextToken != IDENT) {
        std::cout << "Error: expected identifier after type\n";
        return nullptr;
    }

    // Process the first declaration (this consumes IDENT and optional initializer)
    process_single_declaration(currDatatype);

    // Now handle comma-separated further declarations.
    while (nextToken == COMMA)
    {
        lex();  // consume comma

        if (nextToken != IDENT) {
            std::cout << "Error: expected identifier after comma\n";
            return nullptr;
        }

        process_single_declaration(currDatatype);
    }

    // Declaration list doesn't produce AST nodes in your design
    return nullptr;
}
//<assign_list> -> {<ident>=}<assign>
// need to figure out how to handle cases for a = b = ..., like what should the symbol table hold?
// ANSWER TO ABOVE -> PARSER WONT NEED TO HANDLE THIS, THE PARSER WILL ONLY BUILD THE TREE
sNode* assign_list()
{
    if (nextToken != IDENT) return nullptr;

    sNode::Content c;
    c.identifier = lexeme_s[0];
    sNode* lhs = sNode::mkSnode(sNode::IDENTIFIER, c, nullptr, nullptr);
    lex();

    if (nextToken == ASSIGN_OP)
    {
        lex();
        sNode* rhs = assign_list();  // recursively parse the RHS
        sNode::Content opContent; opContent.op = '=';
        return sNode::mkSnode(sNode::OP, opContent, lhs, rhs);
    }

    return assign();  // simple assignment
}

void printSymbolTable(const std::unordered_map<std::string, SymbolInfo>& table)
{
    for (const auto& entry : table)
    {
        const std::string& lname = entry.first;
        const SymbolInfo& info = entry.second;

        std::cout << lname << "  |  ";

        switch (info.type)
        {
            case TYPE_INT:
                std::cout << "INT   ";
                if (info.initialized)
                    std::cout << info.value.i;
                else
                    std::cout << "(uninitialized)";
                break;

            case TYPE_FLOAT:
                std::cout << "FLOAT ";
                if (info.initialized)
                    std::cout << info.value.f;
                else
                    std::cout << "(uninitialized)";
                break;

            default:
                std::cout << "UNKNOWN";
        }

        std::cout << std::endl;
    }
}

void process_single_declaration(Datatype type)
{
    std::string name = lexeme_s;  // full identifier name

    // Insert or update symbol table entry
    symbolTable[name].type = type;
    symbolTable[name].initialized = false;

    lex(); // consume IDENT

    // Optional initializer
    if (nextToken == ASSIGN_OP)
    {
        lex(); // consume '='

        // ---- INT variable initialization ----
        if (type == TYPE_INT)
        {
            if (nextToken == INT_CONST)
            {
                symbolTable[name].value.i = integerLiteral;
                symbolTable[name].initialized = true;
            }
            else
            {
                std::cout << "Type error: cannot assign non-int constant to int variable '"
                          << name << "'\n";
            }
        }
        // ---- FLOAT variable initialization ----
        else if (type == TYPE_FLOAT)
        {
            if (nextToken == FLOAT_CONST)
            {
                symbolTable[name].value.f = floatLiteral;
                symbolTable[name].initialized = true;
            }
            else if (nextToken == INT_CONST)
            {
                // Optional: allow int -> float promotion
                symbolTable[name].value.f = std::stof(lexeme_s);
                symbolTable[name].initialized = true;
            }
            else
            {
                std::cout << "Type error: invalid constant for float variable '"
                          << name << "'\n";
            }
        }

        lex(); // consume constant
    }
}