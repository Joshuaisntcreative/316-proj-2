// syntax analyzer code written in cpp

#include "usefulheaders.hpp"
#include <iostream>
// RUN CODE BY TYPING g++ main.c lex.cpp -o main.exe
//  then do main.exe > main.out

// I split the syntax analyser and the lexical analyser into 2 files for clarity sake, my monitor is small so I can't keep scrolling between the lexical analyser and the syntax analyser on one file and I added a header file just to safeguard all the necessary tokens for this

void assign();
void expr();
void term();
void factor();
void declare_list();
struct SymbolInfo;
std::unordered_map<std::string, SymbolInfo> symbolTable;
void printSymbolTable(std::unordered_map<std::string, SymbolInfo> map);
std::string name;
int depth = 0;
//used as a placeholder until I can find something more concrete
DataType currDatatype;

int incrementGlobalDepth()
{
    return depth += 1;
}

int decrementGlobalDepth()
{
    return depth -=1;
}
/******************************************************/
/* main driver */
int main()
{
    /* Open the input data file and process its contents */
    if ((in_fp = fopen("front.in", "r")) == NULL)
        printf("ERROR - cannot open front.in \n");
    else
    {
        getChar();
        do
        {
            lex();
            declare_list();  
        } while (nextToken != EOF);
        printSymbolTable(symbolTable);
    }
}

/* assign
Parses strings in the language generated by the rule:
<assign> -> {{unsigned|signed}(byte|short|int|long)}<ident>(=|+=|-=|*=|/=|%=) <expr>
*/
void assign()
{
    std::cout << "Enter <assign>" << std::endl;
    // if the start of the front.in is an IDENT = <expr>, to show optional {unsigned|signed} we can run a while loop if the
    if (nextToken == IDENT)
    {
        // get the next token
        lex();
        // the assignment supports the {int|float)} but doesn't change the lexical analyser functionality, by support, means that the lexical analyser recognizes that the keywords and incremental operators are there and will continue with our regular grammar rules.
        // by extension, the assignment will compute the next character by calling lex and then go into expr from our grammar rules
        if (nextToken == ASSIGN_OP)
        {
            lex();
            expr();
        }
    }
}

/* expr
Parses strings in the language generated by the rule:
<expr> -> <term> {(+ | -) <term>}
*/
void expr()
{
    incrementGlobalDepth();
    std::cout << "Enter " << depth << ".<expr>" << std::endl;
    /* Parse the first term */
    term();
    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP)
    {
        lex();
        term();
    }
    std::cout << "Exit " << depth << ".<expr>" << std::endl;
    decrementGlobalDepth();
} /* End of function expr */

/* term
Parses strings in the language generated by the rule:
<term> -> <factor> {(* | /) <factor>)
*/
void term()
{
    incrementGlobalDepth();
    std::cout << "Enter "<< depth << ".<term>" << std::endl;

    /* Parse the first factor */
    factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP)
    {
        lex();
        factor();
    }
    std::cout << "Exit " << depth << ".<term>" << std::endl;
    decrementGlobalDepth();
} /* End of function term */


/* factor
Parses strings in the language generated by the rule:
<factor> -> id | int_constant | ( <expr )
*/
void factor()
{
    incrementGlobalDepth();
    std::cout << "Enter " << depth << ".<factor>" << std::endl;

    if (nextToken == IDENT || nextToken == INT_CONST|| nextToken == FLOAT_CONST)
    {
        lex();
    }
    else
    {
        if (nextToken == LEFT_PAREN)
        {
            lex();
            expr();
            if (nextToken == RIGHT_PAREN)
                lex();
            else
                std::cout << "Error" << std::endl;
        } /* End of if (nextToken == ... */
        /* It was not an id, an integer literal, or a left
        parenthesis */
    } /* End of else */
    std::cout << "Exit " << depth << ".<factor>" << std::endl;
    decrementGlobalDepth();
} /* End of function factor */

void declare_list() 
{
    while (nextToken == INT_KEYWORD || nextToken == FLOAT_KEYWORD)
    {
        // 1. Identify type
        if (nextToken == INT_KEYWORD) {
            currDatatype = TYPE_INT;
        } else if(nextToken == FLOAT_KEYWORD){
            currDatatype = TYPE_FLOAT;
        }
        else{
            //debugging purposes
            currDatatype = TYPE_UNKNOWN;
        }
        lex();
        //Need a way to save the datatype of the identifier and put the value in a symbol table so the, we will use a hashmap for now
        if (nextToken == IDENT)
        {
            name = lexeme_s;  // your lexer should store identifier text
            symbolTable[name].type = currDatatype; // insert into hashmap

            lex(); // consume IDENT
            if(nextToken == ASSIGN_OP)
            {
                lex();
                //const value so either a identifier or a digit
                if(nextToken == IDENT || nextToken == DIGIT)
                {
                    if(nextToken == DIGIT)
                    {
                        symbolTable[name].value = integerLiteral;
                    }
                    //two possible cases 
                    //dont know how to handle other other case where a variable is equal to another variable(i.e what is the symbol table value supposed to be in that case so ill leave that alone for now )

                }
            }
        }
        else
        {
            std::cout<< ("Identifier expected after datatype");
        }

        // allows commas like int a,b,c;
        while (nextToken == COMMA)
        {
            lex();
            if (nextToken != IDENT) std::cout << ("Identifier expected after comma");
            symbolTable[lexeme_s].type = currDatatype;
            lex();
        }
    }

}

void printSymbolTable(std::unordered_map<std::string, SymbolInfo> map)
{
    for (auto i : map)
    {
        std::cout << i.first << " is the name of the identifier and " << i.second.type << " is the type of variable " << i.second.value << " is the value inside" << std::endl;
    }
}

