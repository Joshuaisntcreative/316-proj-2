// syntax analyzer code written in cpp

#include "usefulheaders.hpp"
#include <iostream>
// RUN CODE BY TYPING gcc JAINARINE_23985568.c JAINARINE_23985568_2.c -o JAINARINE_23985568.exe
//  then do JAINARINE_23985568.exe > JAINARINE.out

// I spit the syntax analyser and the lexical analyser into 2 files for clarity sake, my monitor is small so I can't keep scrolling between the lexical analyser and the syntax analyser on one file and I added a header file just to safeguard all the necessary tokens for this

void assign();
void expr();
void term();
void factor();
void exp3();
int depth = 0;

int incrementGlobalDepth()
{
    return depth += 1;
}

int decrementGlobalDepth()
{
    return depth -=1;
}
/******************************************************/
/* main driver */
int main()
{
    /* Open the input data file and process its contents */
    if ((in_fp = fopen("front.in", "r")) == NULL)
        printf("ERROR - cannot open front.in \n");
    else
    {
        getChar();
        do
        {
            lex();
            expr();
        } while (nextToken != EOF);
    }
}

/* assign
Parses strings in the language generated by the rule:
<assign> -> {{unsigned|signed}(byte|short|int|long)}<ident>(=|+=|-=|*=|/=|%=) <expr>
*/
void assign()
{
    std::cout << "Enter <assign>" << std::endl;
    // if the start of the front.in is an IDENT = <expr>, to show optional {unsigned|signed} we can run a while loop if the
    if (nextToken == IDENT || nextToken == INT_KEYWORD || nextToken == FLOAT_KEYWORD)
    {
        // get the next token
        lex();
        // the assignment supports the {int|float)} but doesn't change the lexical analyser functionality, by support, means that the lexical analyser recognizes that the keywords and incremental operators are there and will continue with our regular grammar rules.
        // by extension, the assignment will compute the next character by calling lex and then go into expr from our grammar rules
        if (nextToken == ASSIGN_OP)
        {
            lex();
            expr();
        }
    }
}

/* expr
Parses strings in the language generated by the rule:
<expr> -> <term> {(+ | -) <term>}
*/
void expr()
{
    incrementGlobalDepth();
    std::cout << "Enter " << depth << ".<expr>" << std::endl;
    /* Parse the first term */
    term();
    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP)
    {
        lex();
        term();
    }
    std::cout << "Exit " << depth << ".<expr>" << std::endl;
    decrementGlobalDepth();
} /* End of function expr */

/* term
Parses strings in the language generated by the rule:
<term> -> <factor> {(* | /) <factor>)
*/
void term()
{
    incrementGlobalDepth();
    std::cout << "Enter "<< depth << ".<term>" << std::endl;

    /* Parse the first factor */
    factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP)
    {
        lex();
        factor();
    }
    std::cout << "Exit " << depth << ".<term>" << std::endl;
    decrementGlobalDepth();
} /* End of function term */

void factor()
{
    incrementGlobalDepth();
    std::cout << "Enter " << depth << ".<factor>" << std::endl;
    /*Parse the first exp*/
    exp3();
    /* As long as the next token is a ^ we get the next token and parse the next exp*/
    while (nextToken == POW_OP)
    {
        lex();
        exp3();
    }
    std::cout << "Exit " << depth << ".<factor>" << std::endl;
    decrementGlobalDepth();
}

/* factor
Parses strings in the language generated by the rule:
<factor> -> id | int_constant | ( <expr )
*/
void exp3()
{
    incrementGlobalDepth();
    std::cout << "Enter " << depth << ".<exp>" << std::endl;

    if (nextToken == IDENT || nextToken == INT_LIT)
    {
        lex();
    }
    else
    {
        if (nextToken == LEFT_PAREN)
        {
            lex();
            expr();
            if (nextToken == RIGHT_PAREN)
                lex();
            else
                std::cout << "Error" << std::endl;
        } /* End of if (nextToken == ... */
        /* It was not an id, an integer literal, or a left
        parenthesis */
    } /* End of else */
    std::cout << "Exit " << depth << ".<exp>" << std::endl;
    decrementGlobalDepth();
} /* End of function factor */
