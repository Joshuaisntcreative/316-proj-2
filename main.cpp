// syntax analyzer code written in cpp

#include "usefulheaders.hpp"
#include <iostream>
#include "sNode.hpp"
//#include "printer.cpp"
// RUN CODE BY TYPING g++ main.c lex.cpp -o main.exe
//  then do main.exe > main.out

// I split the syntax analyser and the lexical analyser into 2 files for clarity sake, my monitor is small so I can't keep scrolling between the lexical analyser and the syntax analyser on one file and I added a header file just to safeguard all the necessary tokens for this

sNode *assign();
sNode *assign_list();
sNode *expr();
sNode *term();
sNode *factor();
sNode *declare_list();
sNode *program();
sNode *root;
struct SymbolInfo;
std::unordered_map<std::string, SymbolInfo> symbolTable;
void printSymbolTable(std::unordered_map<std::string, SymbolInfo> map);
std::string name;
// used as a placeholder until I can find something more concrete
DataType currDatatype;


void printAST_ascii(const sNode* node, const std::string& prefix = "", bool isLeft = true)
{
    if (!node) return;

    // Print this node
    std::cout << prefix
              << (isLeft ? "├── " : "└── ");

    switch (node->tag) {
        case sNode::OP:
            std::cout << "OP(" << node->data.op << ")";
            break;
        case sNode::INT_CONSTANT:
            std::cout << "INT(" << node->data.integer_constant << ")";
            break;
        case sNode::FLOAT_CONSTANT:
            std::cout << "FLOAT(" << node->data.float_constant << ")";
            break;
        case sNode::IDENTIFIER:
            std::cout << "ID(" << node->data.identifier << ")";
            break;
        case sNode::DECLARE_LIST:
            std::cout << "DECLARE_LIST";
            break;
        default:
            std::cout << "UNKNOWN";
    }
    std::cout << "\n";

    // Recurse into children
    if (node->left)
        printAST_ascii(node->left, prefix + (isLeft ? "│   " : "    "), true);

    if (node->right)
        printAST_ascii(node->right, prefix + (isLeft ? "│   " : "    "), false);
}
    


/******************************************************/
/* main driver */
int main()
{
    /* Open the input data file and process its contents */
    if ((in_fp = fopen("front.in", "r")) == NULL)
        printf("ERROR - cannot open front.in \n");
    else
    {
        getChar();
        lex();
        root = program();
    }
    printAST_ascii(root);
}
sNode *program()
{

    sNode* first = nullptr;
    sNode* last = nullptr;

    if(nextToken == INT_KEYWORD || nextToken == FLOAT_KEYWORD)
    {
        first = declare_list();
        last = first;
    }
    else{
        std::cout << "Program must start with declareList" << std::endl;
    }
    lex();

   while (nextToken == INT_KEYWORD || nextToken == FLOAT_KEYWORD || nextToken == IDENT)
   {
    sNode* nextNode = nullptr;

    if(nextToken == INT_KEYWORD || nextToken == FLOAT_KEYWORD)
    {
        nextNode = declare_list();
    }
    else{
        nextNode = assign_list();
    }

    last -> right = nextNode;
    last = nextNode;
    //lex();
   }
   return first;
}

/* assign
Parses strings in the language generated by the rule:
<assign> -> <ident> = <expr>
*/
sNode *assign()
{
    // std::cout << "Enter <assign>" << std::endl;
    //  if the start of the front.in is an IDENT = <expr>, to show optional {unsigned|signed} we can run a while loop if the
    if (nextToken == IDENT)
    {
        // so we must create an sNode for the assign = <expr>
        // we will start with making the lhs which is the identifier node
        sNode::Content c;
        c.identifier = lexeme_s[0];

        // this is a simple sNode that creates an identifier node, after we parse through expr,
        // we must create a sNode that sets this lhs Node equal the the rhs.
        sNode *lhs = sNode::mkSnode(sNode::IDENTIFIER, c, nullptr, nullptr);
        // get the next token
        lex();
        // the assignment supports the {int|float)} but doesn't change the lexical analyser functionality, by support, means that the lexical analyser recognizes that the keywords and incremental operators are there and will continue with our regular grammar rules.
        // by extension, the assignment will compute the next character by calling lex and then go into expr from our grammar rules
        if (nextToken == ASSIGN_OP)
        {
            lex();
            // the rhs is the rhs of the = obvs
            sNode *rhs = expr();
            //setting the '=' for the rhs and lhs to create the sNode
            sNode::Content opContent;
            opContent.op = '=';
            return sNode::mkSnode(sNode::OP, opContent, lhs, rhs);
        }
        else{
            std::cerr << "Error, expected = ";
            return nullptr;
        }
    }
}

/* expr
Parses strings in the language generated by the rule:
<expr> -> <term> {(+ | -) <term>}
*/
sNode *expr()
{
    // incrementGlobalDepth();
    // std::cout << "Enter " << depth << ".<expr>" << std::endl;
    /* Parse the first term */
    sNode *left = term();
    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP)
    {
        // fancy notation for which operator to save based on the which token is provided
        char op = (nextToken == ADD_OP ? '+' : '-');
        lex();
        // right hand side of <expr) -> <term> {(+|-) <term>}
        sNode *right = term();
        sNode::Content opContent;
        opContent.op = op;

        //the left node will always be equal to whatever is added on from the right, thats why we keep re assigning it.
        // if the right is null like the grammar implies it can be, then we still return a term();
        left = sNode::mkSnode(sNode::OP, opContent, left, right);
    }
    return left;
    // std::cout << "Exit " << depth << ".<expr>" << std::endl;
    // decrementGlobalDepth();
} /* End of function expr */

/* term
Parses strings in the language generated by the rule:
<term> -> <factor> {(* | /) <factor>)
*/
//pretty much the same as the <expr> expect with (*|/)
sNode *term()
{

    /* Parse the first factor */
    sNode* lhs = factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP)
    {
        char op = (nextToken == MULT_OP ? '*' : '/');
        lex();

        sNode *right = factor();
        sNode::Content opContent;
        //the operator that we set for the node is based of the char op
        opContent.op = op;
        lhs = sNode::mkSnode(sNode::OP, opContent, lhs, right);
    }
    return lhs;

} /* End of function term */

/* factor
Parses strings in the language generated by the rule:
<factor> -> id | int_constant | ( <expr> ) | float_const
*/

// for now, ill assume all identifiers are chars with one word because for some reason, unions in cpp cant deal with strings and I would have to use a struct for that case, i.e int k = 0 works but int kk = 0 wont because kk is a string
sNode *factor()
{
    if (nextToken == IDENT) //|| nextToken == INT_CONST|| nextToken == FLOAT_CONST)
    {
        sNode::Content c;
        c.identifier = lexeme_s[0];
        sNode *n = sNode::mkSnode(
            sNode::IDENTIFIER, c, nullptr, nullptr);
        lex();
        return n;
    }

    if (nextToken == INT_CONST)
    {
        sNode::Content c;
        c.integer_constant = integerLiteral;
        sNode *n = sNode::mkSnode(
            sNode::INT_CONSTANT, c, nullptr, nullptr);
        lex();
        return n;
    }
    // have to add integer literal flexibility to also handle floats.
    if (nextToken == FLOAT_CONST)
    {
        sNode::Content c;
        c.float_constant = integerLiteral;
        sNode *n = sNode::mkSnode(
            sNode::FLOAT_CONSTANT, c, nullptr, nullptr);
        lex();
        return n;
    }
    else
    {
        if (nextToken == LEFT_PAREN)
        {
            lex();
            sNode* n = expr();
            if (nextToken == RIGHT_PAREN)
                lex();
            else
                std::cout << "Error" << std::endl;
            return n;
        } /* End of if (nextToken == ... */

        /* It was not an id, an integer literal, or a left
        parenthesis */
    } /* End of else */
} /* End of function factor */

//declare_list -> (int|float) <ident> [=<expr>]{,<ident>[=<expr>]}
sNode* declare_list()
{
    sNode *lhs = nullptr;
    sNode *rhs = nullptr;
    sNode::Content c;

    // Determine type
    if (nextToken == INT_KEYWORD)
        currDatatype = TYPE_INT;
    else if (nextToken == FLOAT_KEYWORD)
        currDatatype = TYPE_FLOAT;
    else {
        std::cout << "Program error: expected int or float.\n";
        return nullptr;
    }

    lex();  // consume int|float keyword

    // First identifier -----------------------------
    if (nextToken != IDENT) {
        std::cout << "Error: identifier must follow type.\n";
        return nullptr;
    }

    c.identifier = lexeme_s[0];
    lhs = sNode::mkSnode(sNode::IDENTIFIER, c, nullptr, nullptr);

    lex(); // consume identifier

    // Additional identifiers separated by commas ----
    while (nextToken == COMMA)
    {
        lex(); // consume comma

        if (nextToken != IDENT) {
            std::cout << "Error: expected identifier after comma\n";
            return lhs;
        }

        c.identifier = lexeme_s[0];
        rhs = sNode::mkSnode(sNode::IDENTIFIER, c, nullptr, nullptr);
        lex(); // consume identifier

        // Build DECLARE_LIST node
        sNode::Content empty;
        lhs = sNode::mkSnode(
            sNode::DECLARE_LIST,
            empty,
            lhs,
            rhs
        );
    }

    return lhs;
}
//<assign_list> -> {<ident>=}<assign>
// need to figure out how to handle cases for a = b = ..., like what should the symbol table hold?
// ANSWER TO ABOVE -> PARSER WONT NEED TO HANDLE THIS, THE PARSER WILL ONLY BUILD THE TREE
sNode* assign_list()
{
    if (nextToken != IDENT) return nullptr;

    sNode::Content c;
    c.identifier = lexeme_s[0];
    sNode* lhs = sNode::mkSnode(sNode::IDENTIFIER, c, nullptr, nullptr);
    lex();

    if (nextToken == ASSIGN_OP)
    {
        lex();
        sNode* rhs = assign_list();  // recursively parse the RHS
        sNode::Content opContent; opContent.op = '=';
        return sNode::mkSnode(sNode::OP, opContent, lhs, rhs);
    }

    return assign();  // simple assignment
}

void printSymbolTable(std::unordered_map<std::string, SymbolInfo> map)
{
    for (auto i : map)
    {
        std::cout << i.first << " is the name of the identifier and " << i.second.type << " is the type of variable " << i.second.value << " is the value inside" << std::endl;
    }
}
