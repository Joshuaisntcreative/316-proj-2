// syntax analyzer code written in cpp

#include "usefulheaders.hpp"
#include <iostream>
#include "sNode.hpp"
#include "customstack.cpp"
//  RUN CODE BY TYPING g++ main.c lex.cpp sNode.cpp -o main.exe
//   then do main.exe > main.out

// I split the syntax analyser and the lexical analyser into 2 files for clarity sake, my monitor is small so I can't keep scrolling between the lexical analyser and the syntax analyser on one file and I added a header file just to safeguard all the necessary tokens for this

/*
EBNF GRAMMAR
<program> -> <declare_list>{<declare_list>|<assign_list>}
<declare_list> -> (int|float) <ident> [=<const_expr>]{,<ident>[=<const_expr>]
<assign_list> -> {<ident>=}<expr>
<expr> -> <term> {(+ | -) <term>}
<term> -> <factor> {(* | /) <factor>)
<factor> -> id | int_constant | ( <expr> ) | float_const
*/

/*
testCase 1 

int i = 7, j = 8, k
float y, x = 10.5
y = k = (i+j)/(x-6.8)


testCase 2 
int a = 10, b = 20, c = 30
int d
d = b * (c*(a+b))
*/
sNode *assign();
sNode *assign_list();
sNode *expr();
sNode *term();
sNode *factor();
sNode *declare_list();
sNode *program();
sNode *root;
struct SymbolInfo;
std::unordered_map<std::string, SymbolInfo> symbolTable;
void printSymbolTable(const std::unordered_map<std::string, SymbolInfo> &table);
void process_single_declaration(Datatype type);
void printTree(sNode *node, int depth = 0);
static void printIndent(int depth);
std::string typeToString(Datatype t);
Datatype getVariableType(const std::string& id);
void computeTypes(sNode *node);
void generatePostfix(sNode* node);
void evaluateAST(sNode* node, Stack& stack);
// the literal name of the identifier to be inserted into the symbol table
std::string name;
// used as a placeholder until I can find something more concrete
Datatype currDatatype;



//Intermediate language code functions 
void ftoi(Stack& stack);
void itof(Stack& stack);
void iadd(Stack& stack);
void fadd(Stack& stack);
void imult(Stack& stack);
void fmult(Stack& stack);
void idiv(Stack& stack);
void fdiv(Stack& stack);
void isub(Stack& stack);
void fsub(Stack& stack);

/******************************************************/
/* main driver */
int main()
{
    /* Open the input data file and process its contents */
    if ((in_fp = fopen("front.in", "r")) == NULL)
        printf("ERROR - cannot open front.in \n");
    else
    {
        getChar();
        lex();
        root = program();
    }
    //computeTypes(root);
    // printSymbolTable(symbolTable);
    printTree(root);
    //generatePostfix(root);
    //Stack stack;
    //evaluateAST(root,stack);
    printSymbolTable(symbolTable);
}

//<program> -> <declare_list>{<declare_list>|<assign_list>}
sNode *program()
{
    sNode *first = nullptr;
    sNode *last = nullptr;

    // First, process declarations if present
    while (nextToken == INT_KEYWORD || nextToken == FLOAT_KEYWORD)
    {
        declare_list(); // fills symbol table, returns nullptr
        // no AST nodes to link
    }

    // Process assignments if present
    while (nextToken == IDENT)
    {
        sNode *nextNode = assign_list();
        if (!first)
            first = nextNode; // first assignment becomes AST root
        if (last)
            last->right = nextNode;
        last = nextNode;
    }

    return first; // AST only contains assignment nodes
}

/* assign
Parses strings in the language generated by the rule:
<assign> -> <ident> = <expr>
*/
sNode *assign()
{
    if (nextToken != IDENT)
        return nullptr;

    // Build the identifier on LHS
    sNode::Content c;
    c.identifier = lexeme_s[0];
    sNode *lhs = sNode::mkSnode(sNode::IDENTIFIER, c, nullptr, nullptr);

    lex(); // consume IDENT

    if (nextToken == ASSIGN_OP)
    {
        lex(); // consume '='

        // simple assignment â†’ only one level
        sNode *rhs = expr();

        sNode::Content opContent;
        opContent.op = '=';

        return sNode::mkSnode(sNode::OP, opContent, lhs, rhs);
    }

    std::cout << "Error: expected '=' in assign()\n";
    return nullptr;
}

/* expr
Parses strings in the language generated by the rule:
<expr> -> <term> {(+ | -) <term>}
*/
sNode *expr()
{
    // incrementGlobalDepth();
    // std::cout << "Enter " << depth << ".<expr>" << std::endl;
    /* Parse the first term */
    sNode *left = term();
    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP)
    {
        // fancy notation for which operator to save based on the which token is provided
        char op = (nextToken == ADD_OP ? '+' : '-');
        lex();
        // right hand side of <expr) -> <term> {(+|-) <term>}
        sNode *right = term();
        sNode::Content opContent;
        opContent.op = op;

        // the left node will always be equal to whatever is added on from the right, thats why we keep re assigning it.
        //  if the right is null like the grammar implies it can be, then we still return a term();
        left = sNode::mkSnode(sNode::OP, opContent, left, right);
    }
    return left;
    // std::cout << "Exit " << depth << ".<expr>" << std::endl;
    // decrementGlobalDepth();
} /* End of function expr */

/* term
Parses strings in the language generated by the rule:
<term> -> <factor> {(* | /) <factor>)
*/
// pretty much the same as the <expr> expect with (*|/)
sNode *term()
{
    /* Parse the first factor */
    sNode *lhs = factor();
    
    while (nextToken == MULT_OP || nextToken == DIV_OP)
    {
        char op = (nextToken == MULT_OP ? '*' : '/');
        lex(); // Consumes * or /
        
        // This is the *ONLY* place the misalignment can happen.
        // It's possible the lexer failed to skip a space, or a non-printable char.
        // Let's force alignment for the common parenthetical case.
        if (nextToken == LEFT_PAREN) {
            // No action needed, factor() handles it.
        }

        sNode *right = factor();
        sNode::Content opContent;
        opContent.op = op;
        lhs = sNode::mkSnode(sNode::OP, opContent, lhs, right);
    }
    return lhs;
}

/* factor
Parses strings in the language generated by the rule:
<factor> -> id | int_constant | ( <expr> ) | float_const
*/

// for now, ill assume all identifiers are chars with one word because for some reason, unions in cpp cant deal with strings and I would have to use a struct for that case, i.e int k = 0 works but int kk = 0 wont because kk is a string
sNode* factor()
{
    // If factor is called and nextToken is already an operator, it's an error.
    
    if (nextToken == IDENT)
    {
        sNode::Content c;
        c.identifier = lexeme_s; 
        sNode* n = sNode::mkSnode(sNode::IDENTIFIER, c, nullptr, nullptr);
        lex(); // consume IDENT
        return n;
    }

    if (nextToken == INT_CONST)
    {
        sNode::Content c;
        c.integer_constant = integerLiteral;
        sNode* n = sNode::mkSnode(sNode::INT_CONSTANT, c, nullptr, nullptr);
        lex(); // consume INT_CONST
        return n;
    }

    if (nextToken == FLOAT_CONST)
    {
        sNode::Content c;
        c.float_constant = floatLiteral;
        sNode* n = sNode::mkSnode(sNode::FLOAT_CONSTANT, c, nullptr, nullptr);
        lex(); // consume FLOAT_CONST
        return n;
    }

    if (nextToken == LEFT_PAREN)
    {
        lex(); // consume '('
        sNode* n = expr();
        
        // Ensure the closing parenthesis is present and consumed.
        if (nextToken == RIGHT_PAREN)
            lex(); // consume ')' 
        else
            std::cout << "Error: expected ')' in factor" << std::endl;
            
        return n;
    }
    
    // This is where your error occurs: nextToken is not a valid start for a factor.
    // The previous token consumption must have been faulty.
    std::cout << "DEBUG: Factor received unexpected token: " << nextToken 
              << " with lexeme: " << lexeme << std::endl; // Keep this line for future debugging
    std::cout << "Error: unexpected token in factor" << std::endl;
    return nullptr;
}

// declare_list -> (int|float) <ident> [=<expr>]{,<ident>[=<expr>]}
sNode *declare_list()
{
    // Determine type
    if (nextToken == INT_KEYWORD)
        currDatatype = TYPE_INT;
    else if (nextToken == FLOAT_KEYWORD)
        currDatatype = TYPE_FLOAT;
    else
    {
        std::cout << "Error: expected type specifier\n";
        return nullptr;
    }

    lex(); // consume int|float

    // First identifier
    if (nextToken != IDENT)
    {
        std::cout << "Error: expected identifier after type\n";
        return nullptr;
    }

    // Process the first declaration (this consumes IDENT and optional initializer)
    process_single_declaration(currDatatype);

    // Now handle comma-separated further declarations.
    while (nextToken == COMMA)
    {
        lex(); // consume comma

        if (nextToken != IDENT)
        {
            std::cout << "Error: expected identifier after comma\n";
            return nullptr;
        }

        process_single_declaration(currDatatype);
    }

    // Declaration list doesn't produce AST nodes in your design
    return nullptr;
}
//<assign_list> -> {<ident>=}<assign>
// need to figure out how to handle cases for a = b = ..., like what should the symbol table hold?
// ANSWER TO ABOVE -> PARSER WONT NEED TO HANDLE THIS, THE PARSER WILL ONLY BUILD THE TREE
sNode* assign_list()
{
    if (nextToken != IDENT)
        return nullptr;

    sNode* lhsNodes[100];
    int lhsCount = 0;

    // Parse LHS identifiers chain
    while (nextToken == IDENT)
    {
        sNode::Content c;
        c.identifier = lexeme_s;       // <-- full identifier
        lhsNodes[lhsCount++] = sNode::mkSnode(sNode::IDENTIFIER, c, nullptr, nullptr);

        lex(); // consume IDENT

        if (nextToken == ASSIGN_OP)
            lex(); // consume '='
        else
            break; // end of chain
    }

    // Parse RHS as full expression
    sNode* rhs = expr();

    // Build nested assignment tree from right to left
    for (int i = lhsCount - 1; i >= 0; --i)
    {
        sNode::Content opContent;
        opContent.op = '=';
        rhs = sNode::mkSnode(sNode::OP, opContent, lhsNodes[i], rhs);
    }

    return rhs;
}

void printSymbolTable(const std::unordered_map<std::string, SymbolInfo> &table)
{
    std::cout << "---------------------- " <<std::endl;
    std::cout << "Symbol table Contents" <<std::endl;
    std::cout << "Name | Type | Value" << std::endl;
    std::cout << "----------------------" << std::endl;
    for (const auto &entry : table)
    {
        const std::string &lname = entry.first;
        const SymbolInfo &info = entry.second;

        std::cout << lname << "  |  ";

        switch (info.type)
        {
        case TYPE_INT:
            std::cout << "INT   ";
            if (info.initialized)
                std::cout << info.value.i;
            else
                std::cout << "(uninitialized)";
            break;

        case TYPE_FLOAT:
            std::cout << "FLOAT ";
            if (info.initialized)
                std::cout << info.value.f;
            else
                std::cout << "(uninitialized)";
            break;

        default:
            std::cout << "UNKNOWN";
        }

        std::cout << std::endl;
    }
}

void process_single_declaration(Datatype type)
{
    std::string name = lexeme_s; // full identifier name

    // Insert or update symbol table entry
    symbolTable[name].type = type;
    symbolTable[name].initialized = false;

    lex(); // consume IDENT

    // Optional initializer
    if (nextToken == ASSIGN_OP)
    {
        lex(); // consume '='

        // ---- INT variable initialization ----
        if (type == TYPE_INT)
        {
            if (nextToken == INT_CONST)
            {
                symbolTable[name].value.i = integerLiteral;
                symbolTable[name].initialized = true;
            }
            else
            {
                std::cout << "Type error: cannot assign non-int constant to int variable '"
                          << name << "'\n";
            }
        }
        // ---- FLOAT variable initialization ----
        else if (type == TYPE_FLOAT)
        {
            if (nextToken == FLOAT_CONST)
            {
                symbolTable[name].value.f = floatLiteral;
                symbolTable[name].initialized = true;
            }
            else if (nextToken == INT_CONST)
            {
                // Optional: allow int -> float promotion
                symbolTable[name].value.f = std::stof(lexeme_s);
                symbolTable[name].initialized = true;
            }
            else
            {
                std::cout << "Type error: invalid constant for float variable '"
                          << name << "'\n";
            }
        }

        lex(); // consume constant
    }
}

static void printIndent(int depth)
{
    for (int i = 0; i < depth; i++)
        std::cout << "  ";
}

void printTree(sNode *node, int depth)
{
    if (!node)
        return;

    // Indentation
    for (int i = 0; i < depth; ++i)
        std::cout << "  ";

    // Print node info
    switch (node->tag)
    {
    case sNode::IDENTIFIER:
        std::cout << "IDENTIFIER: " << node->data.identifier;
        break;

    case sNode::INT_CONSTANT:
        std::cout << "INT_CONSTANT: " << node->data.integer_constant;
        break;

    case sNode::FLOAT_CONSTANT:
        std::cout << "FLOAT_CONSTANT: " << node->data.float_constant;
        break;

    case sNode::OP:
        std::cout << "OP: " << node->data.op;
        break;

    default:
        std::cout << "UNKNOWN NODE";
    }

    // Print computed and expected types
    std::cout << " [computed: " << typeToString(node->computedType)
              << ", expected: " << typeToString(node->expectedType) << "]"
              << std::endl;

    // Recurse to children
    printTree(node->left, depth + 1);
    printTree(node->right, depth + 1);
}

void computeTypes(sNode *node)
{
    if (!node)
        return;

    // Post-order traversal
    computeTypes(node->left);
    computeTypes(node->right);

    switch (node->tag)
    {
    case sNode::INT_CONSTANT:
        node->computedType = TYPE_INT;
        node->expectedType = TYPE_INT;
        break;

    case sNode::FLOAT_CONSTANT:
        node->computedType = TYPE_FLOAT;
        node->expectedType = TYPE_FLOAT;
        break;

    case sNode::IDENTIFIER:
        node->computedType = getVariableType(node->data.identifier); // now a string
        node->expectedType = node->computedType;
        break;

    case sNode::OP:
        if (node->data.op == '+' || node->data.op == '-' ||
            node->data.op == '*' || node->data.op == '/')
        {
            // Binary arithmetic operators
            if (node->left->computedType == TYPE_FLOAT ||
                node->right->computedType == TYPE_FLOAT)
                node->computedType = TYPE_FLOAT;
            else
                node->computedType = TYPE_INT;

            node->expectedType = node->computedType;
        }
        else if (node->data.op == '=')
        {
            // Assignment
            node->expectedType = node->left->computedType;  // LHS type
            node->computedType = node->right->computedType; // RHS type

            if (node->left->computedType != node->right->computedType)
            {
                std::cout << "Type mismatch in assignment: "
                          << node->left->data.identifier << std::endl;
            }
        }
        break;

    default:
        node->computedType = TYPE_UNKNOWN;
        node->expectedType = TYPE_UNKNOWN;
        break;
    }
}

Datatype getVariableType(const std::string& id)
{
    if (symbolTable.find(id) != symbolTable.end())
        return symbolTable[id].type;
    return TYPE_UNKNOWN;
}
// Helper to convert Type enum to string
std::string typeToString(Datatype t)
{
    switch (t)
    {
    case TYPE_INT:
        return "INT";
    case TYPE_FLOAT:
        return "FLOAT";
    default:
        return "UNKNOWN";
    }
}

void generatePostfix(sNode* node) {
    if (!node) return;

    // Left subtree
    generatePostfix(node->left);

    // Right subtree
    generatePostfix(node->right);

    // Print current node
    switch (node->tag) {
        case sNode::INT_CONSTANT:
            std::cout << node->data.integer_constant << " ";
            break;

        case sNode::FLOAT_CONSTANT:
            std::cout << node->data.float_constant << " ";
            break;

        case sNode::IDENTIFIER:
            std::cout << node->data.identifier << " ";
            break;

        case sNode::OP:
            std::cout << node->data.op << " ";
            break;
    }
}
void evaluateAST(sNode* node, Stack& stack) {
    if (!node) return;

    // Post-order traversal
    evaluateAST(node->left, stack);
    evaluateAST(node->right, stack);

    switch(node->tag) {

        // ---- Leaf nodes ----
        case sNode::INT_CONSTANT: {
            StackValue v;
            v.type = INT_TYPE;
            v.i = node->data.integer_constant;
            stack.push(v);
            std::cout << "PUSH_INT " << v.i << std::endl;
            break;
        }

        case sNode::FLOAT_CONSTANT: {
            StackValue v;
            v.type = FLOAT_TYPE;
            v.f = node->data.float_constant;
            stack.push(v);
            std::cout << "PUSH_FLOAT " << v.f << std::endl;
            break;
        }

        case sNode::IDENTIFIER: {
            std::string name = node->data.identifier; // use string directly
            auto& info = symbolTable[name];
            StackValue v;
            if (info.type == TYPE_INT) {
                v.type = INT_TYPE;
                v.i = info.value.i;
                std::cout << "PUSH_VAR_INT " << name << std::endl;
            } else {
                v.type = FLOAT_TYPE;
                v.f = info.value.f;
                std::cout << "PUSH_VAR_FLOAT " << name << std::endl;
            }
            stack.push(v);
            break;
        }

        // ---- Operators ----
        case sNode::OP: {
            char op = node->data.op;

            if (op == '=') {
                // Right-hand side
                StackValue rhs = stack.pop();

                // Type conversion if needed
                if (rhs.type == INT_TYPE && node->left->computedType == TYPE_FLOAT) {
                    std::cout << "ITOF" << std::endl;
                    stack.push(rhs);
                    itof(stack);
                    rhs = stack.pop();
                } else if (rhs.type == FLOAT_TYPE && node->left->computedType == TYPE_INT) {
                    std::cout << "FTOI" << std::endl;
                    stack.push(rhs);
                    ftoi(stack);
                    rhs = stack.pop();
                }

                // Assign to variable
                std::string varName = node->left->data.identifier; // string directly
                if (rhs.type == INT_TYPE) {
                    symbolTable[varName].value.i = rhs.i;
                    symbolTable[varName].initialized = true;
                } else {
                    symbolTable[varName].value.f = rhs.f;
                    symbolTable[varName].initialized = true;
                }

                std::cout << "STORE " << varName << std::endl;
                stack.push(rhs);  // optional
            } 
            else {
                // Arithmetic operations
                StackValue right = stack.pop();
                StackValue left = stack.pop();

                // Type promotion
                if (left.type == INT_TYPE && right.type == FLOAT_TYPE) {
                    std::cout << "ITOF" << std::endl;
                    stack.push(left);
                    itof(stack);
                    left = stack.pop();
                } else if (left.type == FLOAT_TYPE && right.type == INT_TYPE) {
                    std::cout << "ITOF" << std::endl;
                    stack.push(right);
                    itof(stack);
                    right = stack.pop();
                }

                stack.push(left);
                stack.push(right);

                // Emit IL arithmetic
                switch(op) {
                    case '+':
                        if (node->computedType == TYPE_FLOAT) {
                            fadd(stack);
                            std::cout << "FADD" << std::endl;
                        } else {
                            iadd(stack);
                            std::cout << "IADD" << std::endl;
                        }
                        break;
                    case '-':
                        if (node->computedType == TYPE_FLOAT) {
                            fsub(stack);
                            std::cout << "FSUB" << std::endl;
                        } else {
                            isub(stack);
                            std::cout << "ISUB" << std::endl;
                        }
                        break;
                    case '*':
                        if (node->computedType == TYPE_FLOAT) {
                            fmult(stack);
                            std::cout << "FMULT" << std::endl;
                        } else {
                            imult(stack);
                            std::cout << "IMULT" << std::endl;
                        }
                        break;
                    case '/':
                        if (node->computedType == TYPE_FLOAT) {
                            fdiv(stack);
                            std::cout << "FDIV" << std::endl;
                        } else {
                            idiv(stack);
                            std::cout << "IDIV" << std::endl;
                        }
                        break;
                }
            }
            break;
        }

        default:
            std::cerr << "Unknown node type in evaluation" << std::endl;
            break;
    }
}

// ----- Type conversion -----
void itof(Stack& stack) {
    StackValue v = stack.pop();
    if (v.type != INT_TYPE) {
        std::cerr << "itof error: top of stack is not int\n";
        return;
    }
    StackValue result;
    result.type = FLOAT_TYPE;
    result.f = static_cast<float>(v.i);
    stack.push(result);
}

void ftoi(Stack& stack) {
    StackValue v = stack.pop();
    if (v.type != FLOAT_TYPE) {
        std::cerr << "ftoi error: top of stack is not float\n";
        return;
    }
    StackValue result;
    result.type = INT_TYPE;
    result.i = static_cast<int>(v.f);
    stack.push(result);
}

// ----- Arithmetic operations -----
void iadd(Stack& stack) {
    StackValue b = stack.pop();
    StackValue a = stack.pop();
    StackValue result;
    result.type = INT_TYPE;
    result.i = a.i + b.i;
    stack.push(result);
}

void fadd(Stack& stack) {
    StackValue b = stack.pop();
    StackValue a = stack.pop();
    StackValue result;
    result.type = FLOAT_TYPE;
    result.f = a.f + b.f;
    stack.push(result);
}

void isub(Stack& stack) {
    StackValue b = stack.pop();
    StackValue a = stack.pop();
    StackValue result;
    result.type = INT_TYPE;
    result.i = a.i - b.i;
    stack.push(result);
}

void fsub(Stack& stack) {
    StackValue b = stack.pop();
    StackValue a = stack.pop();
    StackValue result;
    result.type = FLOAT_TYPE;
    result.f = a.f - b.f;
    stack.push(result);
}

void imult(Stack& stack) {
    StackValue b = stack.pop();
    StackValue a = stack.pop();
    StackValue result;
    result.type = INT_TYPE;
    result.i = a.i * b.i;
    stack.push(result);
}

void fmult(Stack& stack) {
    StackValue b = stack.pop();
    StackValue a = stack.pop();
    StackValue result;
    result.type = FLOAT_TYPE;
    result.f = a.f * b.f;
    stack.push(result);
}

void idiv(Stack& stack) {
    StackValue b = stack.pop();
    StackValue a = stack.pop();
    if (b.i == 0) {
        std::cerr << "Division by zero (int)!\n";
        return;
    }
    StackValue result;
    result.type = INT_TYPE;
    result.i = a.i / b.i;
    stack.push(result);
}

void fdiv(Stack& stack) {
    StackValue b = stack.pop();
    StackValue a = stack.pop();
    if (b.f == 0.0f) {
        std::cerr << "Division by zero (float)!\n";
        return;
    }
    StackValue result;
    result.type = FLOAT_TYPE;
    result.f = a.f / b.f;
    stack.push(result);
}